1)a.
unsigned int Raiz_Quadrada(unsigned int S){
unsigned int x = (s+1)/2, n;
if (s < 2 ) return s;
for (n == 0; n<1000 ; n++ ) {
x = (x + s/ x /2);
}
return x;

b.
Raiz_Quadrada:    cmp #2, R15
                  jge Raiz_não_trivial
Raiz_não_trivial: push R5
                  push R6
		  mov R15,R5
	          inc R5
                  rra R5
 		  clr R6
Raiz_loop:        comp #10000, R6
	          jeq Raiz_end
	          push R15
	          mov R5, R14
                  call #div
                  add R1, R5
                  rra R5
                  pop R15
                  inc R6
                  jump Raiz_loop
Raiz_end:         mov R5, R15
                  pop R6
                  pop R5
                  ret

2)
a.
b.

3)
CalculaDiv: mov.w #0,R12  ; Valor temporário da divisão
	    mov.w R15,R13 ; R13 é o registrador temporário utilizado nas mini-divisoes.
	    sub.w #0,R13  ; verifica a divisão por zero.
	    jz FimDiv2    ; se dividir por zero, retorna FFFF.
looping:    sub.w R13,R14 ; subtrai o numerador do denominador, para testar.
	    jn FimDiv     ; divisao termina quando a subtração der negativa.
	    inc.w R12     ; caso contrario, incrementa o valor da divisao temporária.
	    jmp looping   ; retorna ao looping
FimDiv:     mov.w R12,R15 ; transmite o valor da divisão para R15
	    ret	    
FimDiv2:    mov.w #FFFFh, R15 ; transmite o valor "INFINITO" para R15
	    ret

4)
CalculaRDiv: mov.w R15,R13 ; R13 é o registrador temporário utilizado nas mini-divisoes.
	     mov.w R15,R11 ; Valor do resto para quando a divisão é por zero.
	     sub.w #0,R13  ; verifica se a divisão é por zero.
	     jz FimDiv     ; se dividir por zero, o resto é o próprio R15.
looping:     mov.w R13,R11 ; resto da divisão será em R11, antes de subtrair o ultimo valor.
	     sub.w R14,R13 ; R13 = R13 - R14 subtrai o numerador do denominador, para testar...
	     jn FimDiv     ; divisao termina quando a subtração der negativa.
	     jmp looping   ; FOR
FimDiv:      mov.w R11,R15 ; transmite o valor do resto da div para R15
             ret  

5)
a.
int Primalidade(unsigned int x){
	    unsigned int y = 0;
	    int i;
            for(i = 1; i <= x; i++){
                if((x%i)== 0){
                    y++;
                }
            }
            if(y == 2)
                return 1;
            else
                return 0;
	}

b.
Primalidade: mov.w #1,R14	; R14 é o valor do índice (i = 1).
	     mov.w #0,R12	; R12 é o registrador que conta as vezes que o resto é zero.
looping:     push.w R15		; Joga o valor de R15 (Número analisado) para a pilha para usar a função #CalculaRST.
             call #CalculaRST
	     inc.w R14		; i++ 
	     cmp #0,R15		; R15, como é resultado da função CalculaRST, indica o resto da divisão de R15/R14. 
	     jne Condition	; if(R15 == 0) -> R12 ++ //indica se o resto é zero.
	     inc.w R12		; R12 ++ ;
Condition:   pop.w R15          ; Resgata o valor de R15, que é o número a ser analisado.
	     cmp.w R14,R15	;  COMP(R14-R15) Quando i > R15, então a análise terminou.
	     jn FIM
	     jmp looping	; FOR 
FIM:         cmp #2,R12         ; if(R12 == 2){ 
	     jeq true		; 	R15 = 1;
	     mov.w #0,R15	; }else{
	     jmp false		;	R15 = 0;
true:	     mov.w #1,R15	;      }
false:	     ret 